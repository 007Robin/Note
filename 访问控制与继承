/* Robin007 -- 访问控制与继承 */
class Base{
public:
    int pub_mem();
    friend class Pal；       //Pal友元可以正常访问Base的派生类，这种友元关系只对做出声明的类有效
protected:
    int prot_mem;
private:
    char priv_mem;
};
//受保护的成员
class Sneaky : public Base {        //class 默认private继承， struct 默认public继承
    friend void clobber(Sneaky &s) { //能访问Sneaky：：prot_mem
        s.j = s.prot_mem = 0;       //✅ clobber可访问Sneaky对象的private和protected成员
    }
    friend void clobber(Base &b) { //不能访问Base：： prot_mem
        b.prot_mem = 0;            //❌不可访问Base的protect成员
    }
    int j;                      //j 默认private
};
//Public private protected继承
struct Pub_Derv : public Base{
    int f() {
        return prot_mem;    //派生类能访问protected成员
    }
    char g() {
        return priv_mem;     //❌派生类不可访问private成员
    }
};
struct Priv_Derv : private Base{
    //private不影响派生类对Base访问权限，控制派生类用户及其派生类的派生类们对Base成员的访问
    int f1() const {
        return prot_mem;    
    }
};
//用户
Pub_Derv d1;    //继承自Base的成员是public的
Priv_Derv d2;   //继承自Base的成员是private的
d1.pub_mem();   // ✅ pub_mem在派生类是public的
d2.pub_mem();   // ❌ pub_mem在派生类是private的
//派生类的派生类
struct Derived_from_Public : public Pub_Derv {
    int use_base() {
        return prot_mem;    //✅ Base::prot_mem在Pub_Derv中依然是protected的
    }
};

struct Derived_from_Private : public Priv_Derv {
    int use_base() {
        return prot_mem;    //❌ Base::prot_mem在Priv_Derv中是private的
    }
};
//友元与继承
class Pal {
public:
    int f(Base b) {
        return b.prot_mem;      //Pal是Base友元，正常访问Protected的成员
    }
    int f2(Sneaky s) {
        return s.j;         //❌ Pal不是Sneaky的友元
    }
    int f3(Sneaky s) {
        return s.prot_mem;      //✅ Pal是Base的友元，可访问Base对象的成员，即使是内嵌在Base的派生类的对象中的对象，也可访问。
    }
};
//把Pal类声明为Base的友元时，这种友元关系只对做出声明的类有效。
class D2 : public Pal {
public:
    int mem(Base b) {
        return b.prot_mem;      //❌ 友元关系不能继承
    }
};
//提供using声明改变派生类继承的某个名字的访问级别
//using声明语句出现在类的private部分，类的成员和友元可访问该名字
//using声明语句出现在类的public部分，类的所有用户可访问该名字
//using声明语句出现在类的protected部分，类的成员和友元和派生类可访问该名字


